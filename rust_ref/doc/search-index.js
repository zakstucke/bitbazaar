var searchIndex = JSON.parse('{\
"bitbazaar":{"doc":"BitBazaar - A crate containing miscellaneous public …","t":"AOAAAOOAOODMLLMLLFMMLLLGLMMFDNNDENLLLLLLLLLLLLLLLMMLLLLMMFMLLLLLLLLLLLMMMMMMHDLLLFLLLLLLLLL","n":["cli","err","errors","hash","logging","spez","timeit","timing","warn_user_once","warn_user_once_by_id","CmdOut","args","borrow","borrow_mut","code","from","into","run_cmd","stderr","stdout","try_from","try_into","type_id","TracedErr","from","inner","location","fnv1a","ClapLogLevelArgs","Custom","File","LogTarget","LogTargetVariant","Stdout","augment_args","augment_args_for_update","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","fmt","from","from","from","from_arg_matches","from_arg_matches_mut","group_id","include_location_till","include_ts_till","into","into","into","level_filter","level_filter","msg_prefix","setup_logger","silent","try_from","try_from","try_from","try_into","try_into","try_into","type_id","type_id","type_id","update_from_arg_matches","update_from_arg_matches_mut","variant","verbose","dir","file_prefix","include_color","output","GLOBAL_TIME_RECORDER","TimeRecorder","borrow","borrow_mut","default","format_duration","format_verbose","from","into","new","timeit","total_elapsed","try_from","try_into","type_id"],"q":[[0,"bitbazaar"],[10,"bitbazaar::cli"],[23,"bitbazaar::errors"],[27,"bitbazaar::hash"],[28,"bitbazaar::logging"],[72,"bitbazaar::logging::LogTargetVariant"],[76,"bitbazaar::timing"],[91,"core::result"],[92,"core::any"],[93,"core::error"],[94,"core::marker"],[95,"clap_builder::builder::command"],[96,"core::fmt"],[97,"core::fmt"],[98,"clap_builder"],[99,"clap_builder::util::id"],[100,"core::option"],[101,"log"],[102,"alloc::vec"],[103,"fern::builders"],[104,"core::time"],[105,"alloc::string"],[106,"core::ops::function"]],"d":["Command line interface utilities.","A macro for creating a TracedErr from a string or another …","Error handling utilities.","Hashing utilities.","Logging utilities","Spez is a macro used inside our err! macro, need to export …","Time a block of code and log to the global time recorder.","Timing utilities","Warn a user once, with uniqueness determined by the …","Warn a user once, with uniqueness determined by the given …","The result of running a command","The parsed arguments from the command string used in the …","","","The exit code of the command:","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","Run a command entered as a string and return the output","The stderr of the command:","The stdout of the command:","","","","An error type that can be created automatically from any …","","","","FNV1a hash function. Note this is completely insecure, and …","A simple clap argument group for controlling the log level …","Write to a custom output.","Write to files. Where the string is the path to the log …","A target for logging, e.g. stdout, a file, or a custom …","Specify where logs should be written to for a given logger.","Write to stdout:","","","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","","","","Include the write location of the log in each log, e.g. if …","Include the timestamp in each log, e.g. if …","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Convert the clap log level argument group into a log level …","The level to log at and above, e.g. <code>log::LevelFilter::Info</code>","The prefix to add, e.g. the name of the command (e.g. “…","Simple interface to setup a logger and output to a given …","Print diagnostics, but nothing else. Disable all logging …","","","","","","","","","","","","The target to log to, e.g. <code>LogTargetVariant::Stdout {}</code>","Enable verbose logging.","The directory to hold the log files, e.g. <code>./logs/</code>, will …","The prefix for the filenames, e.g. “graphs_”,","Whether to include the color codes in the output, e.g. for …","The custom writer function:","A global time recorder, used by the timeit! macro.","A struct for recording time spent in various blocks of …","","","","Format a duration in a human readable format.","Format the logs in a verbose, table format.","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","Create a new time recorder.","Time a block of code and log to the time recorder.","Using from creation time rather than the specific …","","",""],"i":[0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,0,2,2,2,2,2,0,3,3,3,0,0,28,28,0,0,28,12,12,20,28,12,20,28,12,12,20,28,12,12,12,12,20,20,20,28,12,12,20,20,0,12,20,28,12,20,28,12,20,28,12,12,12,20,12,29,29,30,30,0,0,24,24,24,0,24,24,24,24,24,24,24,24,24],"f":[0,0,0,0,0,0,0,0,0,0,0,0,[-1,-2,[],[]],[-1,-2,[],[]],0,[-1,-1,[]],[-1,-2,[],[]],[1,[[4,[2,3]]]],0,0,[-1,[[4,[-2]]],[],[]],[-1,[[4,[-2]]],[],[]],[-1,5,[]],0,[-1,3,[6,7]],0,0,[[[9,[8]]],10],0,0,0,0,0,0,[11,11],[11,11],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[[12,13],14],[-1,-1,[]],[-1,-1,[]],[-1,-1,[]],[15,[[4,[12,16]]]],[15,[[4,[12,16]]]],[[],[[18,[17]]]],0,0,[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[12,19],0,0,[[[21,[20]]],[[4,[22,3]]]],0,[-1,[[4,[-2]]],[],[]],[-1,[[4,[-2]]],[],[]],[-1,[[4,[-2]]],[],[]],[-1,[[4,[-2]]],[],[]],[-1,[[4,[-2]]],[],[]],[-1,[[4,[-2]]],[],[]],[-1,5,[]],[-1,5,[]],[-1,5,[]],[[12,15],[[4,[23,16]]]],[[12,15],[[4,[23,16]]]],0,0,0,0,0,0,0,0,[-1,-2,[],[]],[-1,-2,[],[]],[[],24],[25,26],[24,[[4,[26,3]]]],[-1,-1,[]],[-1,-2,[],[]],[[],24],[[24,1,-1],-2,27,[]],[24,[[4,[25,3]]]],[-1,[[4,[-2]]],[],[]],[-1,[[4,[-2]]],[],[]],[-1,5,[]]],"c":[],"p":[[15,"str"],[3,"CmdOut",10],[6,"TracedErr",23],[4,"Result",91],[3,"TypeId",92],[8,"Error",93],[8,"Send",94],[15,"u8"],[15,"slice"],[15,"u64"],[3,"Command",95],[3,"ClapLogLevelArgs",28],[3,"Formatter",96],[6,"Result",96],[3,"ArgMatches",97],[6,"Error",98],[3,"Id",99],[4,"Option",100],[4,"LevelFilter",101],[3,"LogTarget",28],[3,"Vec",102],[3,"Dispatch",103],[15,"tuple"],[3,"TimeRecorder",76],[3,"Duration",104],[3,"String",105],[8,"FnOnce",106],[4,"LogTargetVariant",28],[13,"File",72],[13,"Custom",72]]}\
}');
if (typeof window !== 'undefined' && window.initSearch) {window.initSearch(searchIndex)};
if (typeof exports !== 'undefined') {exports.searchIndex = searchIndex};
